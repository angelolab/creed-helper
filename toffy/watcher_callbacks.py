import os
from dataclasses import dataclass, field
import inspect
from typing import Iterable

import matplotlib.pyplot as plt
import pandas as pd
import xarray as xr

from ark.utils import misc_utils

from mibi_bin_tools.bin_files import extract_bin_files, _write_out
from mibi_bin_tools.type_utils import any_true

from toffy.qc_comp import compute_qc_metrics_direct, combine_qc_metrics, visualize_qc_metrics

from toffy.settings import QC_COLUMNS, QC_SUFFIXES


RUN_PREREQUISITES = {
    'plot_qc_metrics': set(['generate_qc']),
}


# If FovCallbacks ever should pass data to RunCallbacks, make this a dataclass following the
# field structure outlined for __fov_data and __panel in FovCallbacks
class RunCallbacks:

    def plot_qc_metrics(self, qc_out_dir: str, **kwargs):
        """Plots qc metrics generated by the `generate_qc` callback

        Args:
            qc_out_dir (str):
                Directory containing qc metric csv
            **kwargs (Dict[str, Any]):
                Additional arguments for `toffy.qc_comp.visualize_qc_metrics`.
                Accepted kwargs are

             - axes_size
             - wrap
             - dpi
             - save_dir
        """
        # filter kwargs
        valid_kwargs = ['axes_size', 'wrap', 'dpi', 'save_dir']
        viz_kwargs = {k: v for k, v in kwargs.items() if k in valid_kwargs}

        combine_qc_metrics(qc_out_dir)

        _, axes = plt.subplots(3, 1)
        for i, (metric_name, ms) in enumerate(zip(QC_COLUMNS, QC_SUFFIXES)):
            qc_df = pd.read_csv(os.path.join(qc_out_dir, 'combined_%s.csv' % ms))
            visualize_qc_metrics(qc_df, metric_name, ax=axes[i], **viz_kwargs)


@dataclass
class FovCallbacks:
    run_folder: str
    point_name: str
    __panel: pd.DataFrame = field(default=None, init=False)
    __fov_data: xr.DataArray = field(default=None, init=False)

    def _generate_fov_data(self, panel: pd.DataFrame, intensities=False, replace=True,
                           time_res=0.0005, **kwargs):
        """Extracts data from bin files using the given panel

        The data and the panel are then cached members of the FovCallbacks object

        Args:
            panel (pd.DataFrame):
                Panel used for extraction
            intensities (bool | List[str]):
                Intensities argument for `mibi_bin_tools.bin_files.extract_bin_files`
            replace (bool):
                Whether to replace pulse images with intensity
            time_res (float):
                Time resolution argument for `mibi_bin_tool.bin_files.extract_bin_files`
            **kwargs (dict):
                Unused kwargs for other functions
        """
        self.__fov_data = extract_bin_files(
            data_dir=self.run_folder,
            out_dir=None,
            include_fovs=[self.point_name],
            panel=panel,
            intensities=intensities,
            replace=replace,
            time_res=time_res
        )

        self.__panel = panel

    def extract_tiffs(self, tiff_out_dir: str, panel: pd.DataFrame, **kwargs):
        """Extract tiffs into provided directory, using given panel

        Args:
            tiff_out_dir (str):
                Path where tiffs are written
            panel (pd.DataFrame):
                Target mass integration ranges
            **kwargs (dict):
                Additional arguments for `mibi_bin_tools.bin_files.extract_bin_files`.
                Accepted kwargs are

             - intensities
             - time_res
        """
        if not os.path.exists(tiff_out_dir):
            os.makedirs(tiff_out_dir)

        if self.__fov_data is None:
            self._generate_fov_data(panel, **kwargs)

        intensities = kwargs.get('intensities', False)
        if any_true(intensities) and type(intensities) is not list:
            intensities = list(self.__fov_data.channel.values)

        _write_out(
            img_data=self.__fov_data[0, :, :, :, :].values,
            out_dir=tiff_out_dir,
            fov_name=self.point_name,
            targets=list(self.__fov_data.channel.values),
            intensities=intensities
        )

    def generate_qc(self, qc_out_dir: str, panel: pd.DataFrame = None, **kwargs):
        """Genereates qc metrics from given panel, and saves output to provided directory

        Args:
            qc_out_dir (str):
                Path where qc_metrics are written
            panel (pd.DataFrame):
                Target mass integration ranges
            **kwargs (dict):
                Additional arguments for `toffy.qc_comp.compute_qc_metrics`. Accepted kwargs are:

             - gaussian_blur
             - blur_factor
        """
        if not os.path.exists(qc_out_dir):
            os.makedirs(qc_out_dir)

        if self.__fov_data is None:
            if panel is None:
                raise ValueError('Must provide panel if fov data is not already generated...')
            self._generate_fov_data(panel, **kwargs)

        metric_data = compute_qc_metrics_direct(
            image_data=self.__fov_data,
            fov_name=self.point_name,
            gaussian_blur=kwargs.get('gaussian_blur', False),
            blur_factor=kwargs.get('blur_factor', 1)
        )

        for metric_name, data in metric_data.items():
            data.to_csv(os.path.join(qc_out_dir, metric_name), index=False)


def build_fov_callback(*args, **kwargs):
    """Assembles callbacks to be run for each transfered FoV

    Args:
        *args (List[str]):
            Names of member functions of `FovCallbacks` to chain together
        **kwargs (Dict[str, Any]):
            Arguments to pass to `FovCallbacks` member functions specified in *args

    Raises:
        ValueError:
            Raised on non-existant member function or missing required kwarg

    Returns:
        Callable[[str, str], None]
            Chained fov callback which will execute all specified callbacks
    """
    # retrieve all 'non-special' methods of FovCallbacks
    methods = [attr for attr in dir(FovCallbacks) if attr[0] != '_']

    # validate user callback settings
    misc_utils.verify_in_list(arg_strings=args, valid_callbacks=methods)
    for arg in args:
        # check that required (non-keyword) arguments for `arg` is present in passed `**kwargs`
        argnames = inspect.getfullargspec(getattr(FovCallbacks, arg))[0]
        argnames = [argname for argname in argnames if argname != 'self']
        misc_utils.verify_in_list(
            required_arguments=argnames,
            passed_arguments=list(kwargs.keys())
        )

    # construct actual callback
    def fov_callback(run_folder: str, point_name: str):
        # construct FovCallback object for given FoV
        callback_obj = FovCallbacks(run_folder, point_name)

        # for each member, retrieve the member function and run it
        for arg in args:
            if cb := getattr(callback_obj, arg, None):
                cb(**kwargs)
            else:
                # unreachable...
                raise ValueError(
                    f'Could not locate attribute {arg} in FovCallback object'
                )

    return fov_callback


def build_callbacks(run_callbacks: Iterable[str],
                    fov_callbacks: Iterable[str] = ('extract_tiffs',), **kwargs):
    """Deduces and assembles all run & FoV callbacks for the watcher function

    Args:
        run_callbacks (Iterable[str]):
            List of run callback names.  These will deduce the prerequisite fov callbacks
        fov_callbacks (Iterable[str]):
            List of fov callbacks to be run, regardless of prerequisite status
        **kwargs (Dict[str, Any]):
            Arguments to pass to `RunCallbacks` and `FovCallbacks` member functions

    Raises:
        ValueError:
            Raised on non-existant member function or missing required kwarg

    Returns:
        Callable[[None,], None], Callable[[str, str], None]:
            Assembled run callback and fov callback
    """

    methods = [attr for attr in dir(RunCallbacks) if attr[0] != '_']

    fov_callbacks = set(fov_callbacks)

    misc_utils.verify_in_list(requested_callbacks=run_callbacks, valid_callbacks=methods)
    for run_cb in run_callbacks:
        argnames = inspect.getfullargspec(getattr(RunCallbacks, run_cb))[0]
        argnames = [argname for argname in argnames if argname != 'self']

        misc_utils.verify_in_list(
            required_arguments=argnames,
            passed_arguments=list(kwargs.keys())
        )

        fov_callbacks = fov_callbacks.union(RUN_PREREQUISITES.get(run_cb, set()))

    fov_callback = build_fov_callback(*list(fov_callbacks), **kwargs)

    def run_callback():
        callback_obj = RunCallbacks()

        for run_cb in run_callbacks:
            if cb := getattr(callback_obj, run_cb, None):
                cb(**kwargs)
            else:
                # unreachable...
                raise ValueError(
                    f'Could not locate attribute {run_cb} in RunCallbacks object'
                )

    return fov_callback, run_callback
